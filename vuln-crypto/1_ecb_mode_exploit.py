#!/usr/bin/env python3
"""
ECB 모드 취약점 Exploit
공격 방법: 동일한 평문 블록이 동일한 암호문을 생성하는 점을 이용
"""

import base64
from typing import List
from Crypto.Cipher import AES

# 취약한 코드에서 가져온 암호화 함수
from Crypto.Util.Padding import pad

SECRET_KEY = b'YELLOW_SUBMARINE'

def encrypt_data(plaintext: str) -> str:
    cipher = AES.new(SECRET_KEY, AES.MODE_ECB)
    padded = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded)
    return base64.b64encode(ciphertext).decode()

def get_blocks(ciphertext_b64: str, block_size: int = 16) -> List[bytes]:
    """암호문을 블록 단위로 분리"""
    ciphertext = base64.b64decode(ciphertext_b64)
    return [ciphertext[i:i+block_size] for i in range(0, len(ciphertext), block_size)]

def detect_ecb_mode():
    """
    ECB 모드 사용 여부 탐지

    ┌─────────────────────────────────────────────────────────────────┐
    │ 1단계: 탐지 - 서버가 ECB 모드를 쓰는지 확인                      │
    └─────────────────────────────────────────────────────────────────┘
    """
    print("=" * 70)
    print("1단계: ECB 모드 탐지")
    print("=" * 70 + "\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 1: 테스트 입력 생성
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 1] 테스트 입력 생성")
    print("    의도: 같은 16바이트 블록을 3번 반복해서 보낸다")
    print("    이유: ECB는 블록 단위로 독립 암호화 → 같은 입력 = 같은 출력\n")

    test_input = "A" * 48  # 3블록 (16바이트 * 3)
    print(f"    입력값: '{test_input}'")
    print(f"    블록 분해:")
    print(f"      블록0: '{test_input[0:16]}' (A 16개)")
    print(f"      블록1: '{test_input[16:32]}' (A 16개)")
    print(f"      블록2: '{test_input[32:48]}' (A 16개)")
    print(f"    → 세 블록 모두 동일한 내용!\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 2: 암호화 요청
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 2] 서버에 암호화 요청")
    encrypted = encrypt_data(test_input)
    blocks = get_blocks(encrypted)

    print(f"    암호문(Base64): {encrypted}\n")
    print(f"    암호문 블록 분해:")
    for i, block in enumerate(blocks):
        print(f"      블록{i}: {block.hex()}")

    # ─────────────────────────────────────────────────────────────────
    # STEP 3: 결과 분석 - 이게 핵심!
    # ─────────────────────────────────────────────────────────────────
    print(f"\n[STEP 3] 결과 분석")

    if blocks[0] == blocks[1] == blocks[2]:
        print("    블록0 == 블록1 == 블록2  →  TRUE!\n")

        print("    ┌─────────────────────────────────────────────────────────┐")
        print("    │ 이것이 의미하는 것:                                      │")
        print("    ├─────────────────────────────────────────────────────────┤")
        print("    │ 1. 서버가 ECB 모드를 사용 중                             │")
        print("    │ 2. 같은 평문 블록 → 항상 같은 암호문 블록                │")
        print("    │ 3. 블록 간에 아무런 연결(체이닝)이 없음                  │")
        print("    └─────────────────────────────────────────────────────────┘")

        print("\n    ┌─────────────────────────────────────────────────────────┐")
        print("    │ 이것을 이용한 공격 가능성:                               │")
        print("    ├─────────────────────────────────────────────────────────┤")
        print("    │ 1. Byte-at-a-time 공격                                  │")
        print("    │    → 비밀 데이터를 한 글자씩 추출 가능                   │")
        print("    │                                                         │")
        print("    │ 2. 블록 재배열 공격                                      │")
        print("    │    → 암호문 블록 순서를 바꿔 메시지 조작 가능            │")
        print("    │                                                         │")
        print("    │ 3. 패턴 분석                                            │")
        print("    │    → 암호문만 봐도 평문 구조 유추 가능                   │")
        print("    └─────────────────────────────────────────────────────────┘\n")
        return True

    print("    블록들이 서로 다름 → ECB 아닐 가능성 높음")
    return False

def byte_at_a_time_attack():
    """
    Byte-at-a-time ECB 복호화 공격

    ┌─────────────────────────────────────────────────────────────────┐
    │ 2단계: 공격 - ECB 특성을 이용해 비밀 데이터 추출                 │
    └─────────────────────────────────────────────────────────────────┘

    공격 시나리오:
      서버가 "사용자입력 + 비밀데이터" 를 암호화해서 반환
      → 공격자는 비밀데이터를 한 글자씩 알아낼 수 있음!
    """
    print("=" * 70)
    print("2단계: Byte-at-a-time ECB 공격")
    print("=" * 70 + "\n")

    # ─────────────────────────────────────────────────────────────────
    # 공격 상황 설명
    # ─────────────────────────────────────────────────────────────────
    print("[공격 상황]")
    print("    서버 동작: encrypt(사용자입력 + 비밀데이터)")
    print("    예: 사용자가 'AAA' 입력 → 서버가 'AAA' + 'SECRET:...' 암호화")
    print("    공격자 목표: 비밀데이터 내용을 알아내기\n")

    secret_suffix = "SECRET:admin_password=SuperSecret123!"
    block_size = 16

    print(f"    [시뮬레이션] 비밀데이터: '{secret_suffix}'")
    print(f"    (실제 공격에서는 이걸 모르는 상태에서 추출해냄)\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 1: 공격 원리 설명
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 1] 공격 원리")
    print("    ┌────────────────────────────────────────────────────────┐")
    print("    │ ECB 특성: 같은 평문 블록 → 같은 암호문 블록            │")
    print("    │                                                        │")
    print("    │ 이걸 이용해서:                                         │")
    print("    │ 1. 패딩을 조절해 비밀의 첫 글자를 블록 끝으로 밀기     │")
    print("    │ 2. 모든 문자(A-Z, a-z, 0-9...)로 추측해서 암호화       │")
    print("    │ 3. 암호문이 일치하면 → 그 글자가 정답!                 │")
    print("    └────────────────────────────────────────────────────────┘\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 2: 첫 번째 글자 추출 과정 상세 설명
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 2] 첫 번째 글자 'S' 추출 과정 (상세)")
    print("-" * 60)

    # 15개의 A를 보내서 비밀의 첫 글자를 블록 끝으로 이동
    padding = "A" * 15
    print(f"    2-1. 패딩 15개 전송: '{padding}'")
    print(f"")
    print(f"    2-2. 서버에서 일어나는 일:")
    print(f"         입력:     '{padding}' (15바이트)")
    print(f"         + 비밀:   '{secret_suffix}'")
    print(f"         = 합쳐짐: '{padding + secret_suffix[:1]}|...'")
    print(f"                    ↑")
    print(f"         첫 블록:  [AAAAAAAAAAAAAAA S]  ← 비밀 첫 글자가 블록 끝에!")
    print(f"                    |-- 16바이트 --|")

    target_encrypted = encrypt_data(padding + secret_suffix)
    target_block = get_blocks(target_encrypted)[0]
    print(f"\n    2-3. 타겟 암호문 블록: {target_block.hex()}")

    print(f"\n    2-4. 이제 모든 문자를 시도해서 매칭 찾기:")
    print(f"         'AAAAAAAAAAAAAAA' + '?' 를 암호화해서 타겟과 비교\n")

    # 실제로 몇 개만 보여주기
    for test_char in ['A', 'B', 'R', 'S']:  # S가 정답
        test_input = padding + test_char
        test_encrypted = encrypt_data(test_input)
        test_block = get_blocks(test_encrypted)[0]
        match = "← 일치!" if test_block == target_block else ""
        print(f"         '{padding}{test_char}' → {test_block.hex()} {match}")

    print(f"\n    2-5. 결론: 'S'일 때 암호문이 일치 → 비밀 첫 글자는 'S'!")

    # ─────────────────────────────────────────────────────────────────
    # STEP 3: 전체 비밀 추출
    # ─────────────────────────────────────────────────────────────────
    print("\n" + "-" * 60)
    print("[STEP 3] 전체 비밀 추출 (처음 16글자)")
    print("-" * 60)

    discovered = ""
    for byte_pos in range(min(16, len(secret_suffix))):
        padding_length = block_size - 1 - byte_pos
        padding = "A" * padding_length

        target_encrypted = encrypt_data(padding + secret_suffix)
        target_block = get_blocks(target_encrypted)[0]

        for byte_val in range(256):
            try:
                test_char = chr(byte_val)
                test_input = padding + discovered + test_char
                test_encrypted = encrypt_data(test_input)
                test_block = get_blocks(test_encrypted)[0]

                if test_block == target_block:
                    discovered += test_char
                    print(f"    [{byte_pos+1:2d}/16] 패딩 {padding_length:2d}개 + 추측 '{test_char}' → 발견! 현재: '{discovered}'")
                    break
            except:
                continue

    print(f"\n    ┌────────────────────────────────────────────────────────┐")
    print(f"    │ 공격 성공!                                             │")
    print(f"    │ 복구된 비밀: '{discovered}'              │")
    print(f"    │                                                        │")
    print(f"    │ 왜 이게 가능했나?                                      │")
    print(f"    │ → ECB가 블록을 독립적으로 암호화하기 때문              │")
    print(f"    │ → 같은 입력 = 같은 출력이라는 특성을 악용              │")
    print(f"    └────────────────────────────────────────────────────────┘")

def block_reordering_attack():
    """
    ECB 블록 재배열/교체 공격

    ┌─────────────────────────────────────────────────────────────────┐
    │ 3단계: 블록 교체 공격 - 암호문 블록을 조합해서 메시지 조작       │
    └─────────────────────────────────────────────────────────────────┘
    """
    print("\n" + "=" * 70)
    print("3단계: ECB 블록 재배열/교체 공격")
    print("=" * 70 + "\n")

    # ─────────────────────────────────────────────────────────────────
    # 공격 시나리오
    # ─────────────────────────────────────────────────────────────────
    print("[공격 시나리오]")
    print("    상황: 은행 서버가 거래 요청을 암호화해서 저장")
    print("    형식: 'user=xxx.....&to=yyy.....&amt=zzz.....'")
    print("         (각 필드가 16바이트 블록에 딱 맞게 정렬됨)")
    print("    공격자 목표: 100원 송금을 999원으로 변조!\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 1: ECB의 블록 독립성 이해
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 1] ECB의 블록 독립성")
    print("    ┌────────────────────────────────────────────────────────┐")
    print("    │ ECB 특성: 각 블록이 독립적으로 암호화됨                │")
    print("    │                                                        │")
    print("    │ 평문:  [블록A][블록B][블록C]                           │")
    print("    │         ↓     ↓     ↓                                 │")
    print("    │ 암호문: [E(A)][E(B)][E(C)]                             │")
    print("    │                                                        │")
    print("    │ 따라서 블록 순서를 바꾸거나 교체해도 복호화 가능!      │")
    print("    └────────────────────────────────────────────────────────┘\n")

    # ─────────────────────────────────────────────────────────────────
    # STEP 2: 공격 준비 - 두 개의 거래 생성
    # ─────────────────────────────────────────────────────────────────
    print("[STEP 2] 공격 준비 - 공격자의 두 거래")
    print("-" * 60)

    # 16바이트로 맞춘 메시지들
    legit_msg = "user=attacker___" + "to=bob__________" + "amt=0100________"  # 정당한 100원
    fake_msg  = "user=attacker___" + "to=bob__________" + "amt=9999________"  # 9999원 (이건 승인 안 됨)

    print(f"    거래1 (정당한 거래, 승인됨):")
    print(f"      블록0: '{legit_msg[0:16]}'  (사용자)")
    print(f"      블록1: '{legit_msg[16:32]}' (받는사람)")
    print(f"      블록2: '{legit_msg[32:48]}' (금액: 100원)")

    enc_legit = encrypt_data(legit_msg)
    blocks_legit = get_blocks(enc_legit)

    print(f"      암호문 블록들:")
    print(f"        블록0: {blocks_legit[0].hex()}")
    print(f"        블록1: {blocks_legit[1].hex()}")
    print(f"        블록2: {blocks_legit[2].hex()} ← 100원 블록")

    print(f"\n    거래2 (공격자가 따로 만든 거래):")
    print(f"      블록0: '{fake_msg[0:16]}'  (사용자)")
    print(f"      블록1: '{fake_msg[16:32]}' (받는사람)")
    print(f"      블록2: '{fake_msg[32:48]}' (금액: 9999원)")

    enc_fake = encrypt_data(fake_msg)
    blocks_fake = get_blocks(enc_fake)

    print(f"      암호문 블록들:")
    print(f"        블록0: {blocks_fake[0].hex()}")
    print(f"        블록1: {blocks_fake[1].hex()}")
    print(f"        블록2: {blocks_fake[2].hex()} ← 9999원 블록")

    # ─────────────────────────────────────────────────────────────────
    # STEP 3: 블록 교체 공격!
    # ─────────────────────────────────────────────────────────────────
    print(f"\n[STEP 3] 블록 교체 공격 수행")
    print("-" * 60)

    print("    공격 방법:")
    print("      1. 정당한 거래의 암호문에서 블록0, 블록1 가져옴")
    print("      2. 가짜 거래의 암호문에서 블록2(9999원) 가져옴")
    print("      3. 조합: [정당블록0][정당블록1][가짜블록2]\n")

    # 조작된 암호문 생성
    tampered_blocks = blocks_legit[0] + blocks_legit[1] + blocks_fake[2] + blocks_legit[3]
    tampered_ciphertext = base64.b64encode(tampered_blocks).decode()

    print(f"    조작된 암호문:")
    print(f"      블록0: {blocks_legit[0].hex()} (정당한 user)")
    print(f"      블록1: {blocks_legit[1].hex()} (정당한 to)")
    print(f"      블록2: {blocks_fake[2].hex()} (가짜 9999원!)")

    # 복호화해서 확인
    from Crypto.Cipher import AES
    from Crypto.Util.Padding import unpad
    cipher = AES.new(SECRET_KEY, AES.MODE_ECB)
    decrypted = unpad(cipher.decrypt(tampered_blocks), AES.block_size)

    print(f"\n    서버에서 복호화 결과:")
    print(f"      '{decrypted.decode()}'")

    print(f"\n    ┌────────────────────────────────────────────────────────┐")
    print(f"    │ 공격 성공!                                             │")
    print(f"    │                                                        │")
    print(f"    │ 원래: 100원 송금 (승인됨)                              │")
    print(f"    │ 변조: 9999원 송금 (서버는 모름!)                       │")
    print(f"    │                                                        │")
    print(f"    │ 왜 이게 가능했나?                                      │")
    print(f"    │ → ECB에서 각 블록이 독립적으로 암/복호화됨             │")
    print(f"    │ → 블록을 바꿔치기해도 서버가 감지할 수 없음            │")
    print(f"    │ → MAC(메시지 인증 코드)이 없으면 무결성 검증 불가      │")
    print(f"    └────────────────────────────────────────────────────────┘")

if __name__ == "__main__":
    print("=" * 60)
    print("ECB 모드 취약점 Exploit 데모")
    print("=" * 60 + "\n")

    # 1. ECB 모드 탐지
    detect_ecb_mode()

    # 2. Byte-at-a-time 공격
    byte_at_a_time_attack()

    # 3. 블록 재배열 공격
    block_reordering_attack()

    print("\n" + "=" * 60)
    print("해결 방법: CBC, CTR, GCM 등 안전한 모드 사용")
    print("=" * 60)
