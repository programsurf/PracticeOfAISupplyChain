#!/usr/bin/env python3
"""
ECB 모드 취약점 Exploit
공격 방법: 동일한 평문 블록이 동일한 암호문을 생성하는 점을 이용
"""

import base64
from typing import List
from Crypto.Cipher import AES

# 취약한 코드에서 가져온 암호화 함수
from Crypto.Util.Padding import pad

SECRET_KEY = b'YELLOW_SUBMARINE'

def encrypt_data(plaintext: str) -> str:
    cipher = AES.new(SECRET_KEY, AES.MODE_ECB)
    padded = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded)
    return base64.b64encode(ciphertext).decode()

def get_blocks(ciphertext_b64: str, block_size: int = 16) -> List[bytes]:
    """암호문을 블록 단위로 분리"""
    ciphertext = base64.b64decode(ciphertext_b64)
    return [ciphertext[i:i+block_size] for i in range(0, len(ciphertext), block_size)]

def detect_ecb_mode():
    """ECB 모드 사용 여부 탐지"""
    print("=== ECB 모드 탐지 ===\n")

    # 동일한 블록을 반복하여 전송
    test_input = "A" * 48  # 3블록 (16바이트 * 3)
    encrypted = encrypt_data(test_input)
    blocks = get_blocks(encrypted)

    print(f"테스트 입력: {test_input}")
    print(f"암호문 블록들:")
    for i, block in enumerate(blocks):
        print(f"  블록 {i}: {block.hex()}")

    # 블록이 반복되는지 확인
    if blocks[0] == blocks[1] == blocks[2]:
        print("\n[!] ECB 모드 탐지됨! 동일한 평문이 동일한 암호문을 생성합니다.\n")
        return True
    return False

def byte_at_a_time_attack():
    """Byte-at-a-time ECB 복호화 공격"""
    print("=== Byte-at-a-time ECB 공격 ===\n")

    # 비밀 데이터의 길이 찾기
    secret_suffix = "SECRET:admin_password=SuperSecret123!"

    # 블록 크기 탐지
    block_size = 16

    # 한 바이트씩 복구
    discovered = ""

    print("비밀 데이터를 한 바이트씩 복구 중...\n")

    # 간단한 예시: 첫 번째 블록만 공격
    for byte_pos in range(min(16, len(secret_suffix))):
        # 패딩을 조절하여 알고 싶은 바이트를 블록 끝으로 이동
        padding_length = block_size - 1 - byte_pos
        padding = "A" * padding_length

        # 타겟 암호문 블록 얻기
        target_encrypted = encrypt_data(padding + secret_suffix)
        target_block = get_blocks(target_encrypted)[0]

        # 모든 가능한 바이트 시도
        for byte_val in range(256):
            test_input = padding + discovered + chr(byte_val)
            test_encrypted = encrypt_data(test_input)
            test_block = get_blocks(test_encrypted)[0]

            if test_block == target_block:
                discovered += chr(byte_val)
                print(f"발견된 바이트 {byte_pos + 1}: '{chr(byte_val)}' -> 지금까지: '{discovered}'")
                break

    print(f"\n[+] 복구된 데이터: {discovered}")

def block_reordering_attack():
    """ECB 블록 재배열 공격"""
    print("\n=== ECB 블록 재배열 공격 ===\n")

    # 공격자가 원하는 메시지 조작
    msg1 = "transfer=1000won"  # 16바이트
    msg2 = "transfer=9999won"  # 16바이트

    enc1 = encrypt_data(msg1)
    enc2 = encrypt_data(msg2)

    blocks1 = get_blocks(enc1)
    blocks2 = get_blocks(enc2)

    print(f"원본 메시지 1: {msg1}")
    print(f"암호문 1 블록: {blocks1[0].hex()}\n")

    print(f"원본 메시지 2: {msg2}")
    print(f"암호문 2 블록: {blocks2[0].hex()}\n")

    # 블록을 교체하여 메시지 변조
    print("[!] 공격자가 암호문 블록을 교체하면 메시지를 변조할 수 있습니다!")
    print("    (실제 시스템에서는 MAC/인증이 필요한 이유)")

if __name__ == "__main__":
    print("=" * 60)
    print("ECB 모드 취약점 Exploit 데모")
    print("=" * 60 + "\n")

    # 1. ECB 모드 탐지
    detect_ecb_mode()

    # 2. Byte-at-a-time 공격
    byte_at_a_time_attack()

    # 3. 블록 재배열 공격
    block_reordering_attack()

    print("\n" + "=" * 60)
    print("해결 방법: CBC, CTR, GCM 등 안전한 모드 사용")
    print("=" * 60)
