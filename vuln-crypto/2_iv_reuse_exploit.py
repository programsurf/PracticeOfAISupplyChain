#!/usr/bin/env python3
"""
IV 재사용 취약점 Exploit
공격 방법: CBC 모드에서 같은 IV를 사용하면 평문 간의 XOR 관계를 추출할 수 있음
"""

import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

SECRET_KEY = b'SIXTEEN_BYTE_KEY'
FIXED_IV = b'FIXED_IV_16BYTES'

def encrypt_with_reused_iv(plaintext: str) -> str:
    cipher = AES.new(SECRET_KEY, AES.MODE_CBC, FIXED_IV)
    padded = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded)
    return base64.b64encode(ciphertext).decode()

def xor_bytes(a: bytes, b: bytes) -> bytes:
    """두 바이트열을 XOR"""
    return bytes(x ^ y for x, y in zip(a, b))

def detect_iv_reuse():
    """IV 재사용 탐지"""
    print("=== IV 재사용 탐지 ===\n")

    # 동일한 평문을 두 번 암호화
    plaintext = "This is a test message for IV reuse detection!!"
    enc1 = encrypt_with_reused_iv(plaintext)
    enc2 = encrypt_with_reused_iv(plaintext)

    print(f"평문: {plaintext}")
    print(f"암호문 1: {enc1}")
    print(f"암호문 2: {enc2}")

    if enc1 == enc2:
        print("\n[!] IV 재사용 탐지! 동일한 평문이 동일한 암호문을 생성합니다.\n")
        return True
    return False

def known_plaintext_attack():
    """알려진 평문 공격"""
    print("=== 알려진 평문 공격 ===\n")

    # 공격자가 일부 평문을 알고 있는 경우
    known_msg = "Transfer 1000 won to Alice"
    unknown_msg = "Transfer 9999 won to Admin"  # 공격자가 모르는 메시지

    # 같은 IV로 암호화됨
    enc_known = encrypt_with_reused_iv(known_msg)
    enc_unknown = encrypt_with_reused_iv(unknown_msg)

    print(f"알려진 메시지: {known_msg}")
    print(f"알려진 메시지 암호문: {enc_known}\n")

    print(f"알 수 없는 메시지 암호문: {enc_unknown}")

    # CBC 모드 특성 상, 첫 번째 블록은 IV와 XOR되므로
    # C1 = E(P1 ⊕ IV)
    # 같은 IV를 사용하면 첫 번째 블록에서 관계를 찾을 수 있음

    ct_known = base64.b64decode(enc_known)
    ct_unknown = base64.b64decode(enc_unknown)

    # 첫 16바이트 비교
    block1_known = ct_known[:16]
    block1_unknown = ct_unknown[:16]

    print(f"\n첫 번째 블록 (알려진): {block1_known.hex()}")
    print(f"첫 번째 블록 (모르는): {block1_unknown.hex()}")

    # 만약 평문의 패턴을 알고 있다면...
    print("\n[!] IV를 재사용하면 공격자가 패턴 분석 및 평문 복구를 할 수 있습니다.")

def bit_flipping_attack():
    """비트 플리핑 공격 (IV 변조)"""
    print("\n=== 비트 플리핑 공격 ===\n")

    # 원본 메시지
    original = "user_id:attacker"
    encrypted = encrypt_with_reused_iv(original)

    print(f"원본 메시지: {original}")
    print(f"암호문: {encrypted}\n")

    # IV를 알고 있으므로 (또는 추측 가능), 첫 번째 블록을 조작 가능
    # CBC 모드: P1 = D(C1) ⊕ IV
    # 따라서 IV를 변조하면 P1을 변조 가능

    # 예: "attacker"를 "adminXXX"로 변경하고 싶다면
    # 필요한 변화: "attacker" -> "adminXXX"
    # 이를 위해 IV의 해당 바이트를 XOR

    original_bytes = original.encode()
    target_bytes = b"user_id:adminXXX"

    # IV 변조 계산
    iv_original = FIXED_IV
    iv_modified = xor_bytes(
        xor_bytes(iv_original, original_bytes),
        target_bytes
    )

    print(f"원본 IV: {iv_original.hex()}")
    print(f"변조된 IV: {iv_modified.hex()}\n")

    # 변조된 IV로 복호화
    cipher = AES.new(SECRET_KEY, AES.MODE_CBC, iv_modified)
    ciphertext = base64.b64decode(encrypted)
    try:
        from Crypto.Util.Padding import unpad
        plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size)
        print(f"[+] 변조된 평문: {plaintext.decode()}")
        print("[!] 공격 성공! IV를 변조하여 평문을 조작했습니다.")
    except:
        print("[!] 패딩 오류 발생 (실제 공격에서는 패딩을 조정해야 함)")

def replay_attack():
    """재생 공격"""
    print("\n=== 재생 공격 ===\n")

    # 같은 IV를 사용하면 이전 메시지를 재전송할 수 있음
    message = "Transfer 1000 won from Alice to Bob"
    encrypted = encrypt_with_reused_iv(message)

    print(f"가로챈 메시지: {message}")
    print(f"가로챈 암호문: {encrypted}\n")

    print("[!] 공격자가 이 암호문을 재전송하면 동일한 거래가 반복 실행됨")
    print("    (타임스탬프나 nonce가 없으면 방어 불가)")

if __name__ == "__main__":
    print("=" * 60)
    print("IV 재사용 취약점 Exploit 데모")
    print("=" * 60 + "\n")

    # 1. IV 재사용 탐지
    detect_iv_reuse()

    # 2. 알려진 평문 공격
    known_plaintext_attack()

    # 3. 비트 플리핑 공격
    bit_flipping_attack()

    # 4. 재생 공격
    replay_attack()

    print("\n" + "=" * 60)
    print("해결 방법: 매번 랜덤한 IV 사용 + 인증(MAC) + Nonce/Timestamp")
    print("=" * 60)
