#!/usr/bin/env python3
"""
Padding Oracle 공격
공격 방법: 패딩 오류 메시지를 이용하여 암호문을 복호화
"""

import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes

SECRET_KEY = b'SECRET_KEY_16BYT'

def decrypt_vulnerable(ciphertext_b64: str) -> tuple:
    """취약한 복호화 함수 (패딩 오류를 구분하여 반환)"""
    try:
        data = base64.b64decode(ciphertext_b64)
        iv = data[:16]
        ciphertext = data[16:]

        cipher = AES.new(SECRET_KEY, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)

        try:
            from Crypto.Util.Padding import unpad
            plaintext = unpad(padded_plaintext, AES.block_size)
            return (True, "Success", plaintext.decode())
        except ValueError:
            return (False, "Padding Error", None)
    except Exception as e:
        return (False, f"Decryption Error: {str(e)}", None)

def padding_oracle(ciphertext_b64: str) -> bool:
    """
    패딩 오라클: 패딩이 올바른지 확인
    True: 패딩이 올바름
    False: 패딩이 잘못됨
    """
    success, message, _ = decrypt_vulnerable(ciphertext_b64)
    # "Padding Error"가 아니면 패딩이 올바른 것
    return message != "Padding Error"

def xor_bytes(a: bytes, b: bytes) -> bytes:
    """두 바이트열을 XOR"""
    return bytes(x ^ y for x, y in zip(a, b))

def decrypt_block_with_oracle(iv: bytes, ciphertext_block: bytes) -> bytes:
    """
    Padding Oracle을 이용한 블록 복호화

    CBC 모드: P = D(C) ⊕ IV
    패딩 오라클을 이용하여 D(C)를 복구하고, IV와 XOR하여 평문 복구
    """
    block_size = 16
    decrypted = bytearray(block_size)
    intermediate = bytearray(block_size)

    # 뒤에서부터 한 바이트씩 공격
    for pad_value in range(1, block_size + 1):
        # 현재 패딩 값에 맞게 이미 알아낸 바이트들을 조정
        attack_iv = bytearray(block_size)

        for i in range(block_size - pad_value + 1, block_size):
            attack_iv[i] = intermediate[i] ^ pad_value

        # 현재 바이트 찾기
        target_index = block_size - pad_value

        for byte_value in range(256):
            attack_iv[target_index] = byte_value

            # 테스트
            test_data = bytes(attack_iv) + ciphertext_block
            test_b64 = base64.b64encode(test_data).decode()

            if padding_oracle(test_b64):
                # 올바른 패딩을 찾음
                intermediate[target_index] = byte_value ^ pad_value

                # 마지막 바이트는 여러 값이 가능할 수 있으므로 추가 검증
                if pad_value == 1:
                    # 패딩이 0x02 0x02도 유효한지 확인
                    attack_iv[target_index - 1] ^= 1
                    test_data2 = bytes(attack_iv) + ciphertext_block
                    test_b642 = base64.b64encode(test_data2).decode()

                    if not padding_oracle(test_b642):
                        continue  # 다른 값 시도

                break

    # 평문 복구: P = D(C) ⊕ IV
    decrypted = xor_bytes(intermediate, iv)
    return bytes(decrypted)

def padding_oracle_attack_demo():
    """Padding Oracle 공격 데모"""
    print("=== Padding Oracle 공격 데모 ===\n")

    # 공격 대상 암호문 생성
    plaintext = "SECRET_MESSAGE!!"
    iv = get_random_bytes(16)
    cipher = AES.new(SECRET_KEY, AES.MODE_CBC, iv)
    padded = pad(plaintext.encode(), AES.block_size)
    ciphertext = cipher.encrypt(padded)

    print(f"원본 평문: {plaintext}")
    print(f"암호문 (hex): {ciphertext.hex()}\n")

    # 공격 시작
    print("[*] Padding Oracle 공격 시작...\n")

    try:
        # 첫 번째 블록만 공격 (데모)
        recovered = decrypt_block_with_oracle(iv, ciphertext[:16])
        print(f"[+] 복구된 평문: {recovered}")

        # 패딩 제거
        try:
            from Crypto.Util.Padding import unpad
            recovered_unpadded = unpad(recovered, AES.block_size)
            print(f"[+] 패딩 제거 후: {recovered_unpadded.decode()}\n")
        except:
            print(f"[+] 복구된 데이터 (raw): {recovered.hex()}\n")

        print("[!] 공격 성공! 패딩 오라클을 이용하여 암호문을 복호화했습니다.")

    except Exception as e:
        print(f"[!] 공격 실패 또는 오류: {e}")
        print("[*] 실제 공격에서는 더 정교한 방법이 필요할 수 있습니다.")

def demonstrate_vulnerability():
    """취약점 시연"""
    print("\n=== 취약점 설명 ===\n")

    # 정상 데이터
    iv = get_random_bytes(16)
    cipher = AES.new(SECRET_KEY, AES.MODE_CBC, iv)
    padded = pad(b"Normal data", AES.block_size)
    ct = cipher.encrypt(padded)

    normal_token = base64.b64encode(iv + ct).decode()

    # 패딩 오류 데이터
    ct_bad_padding = ct[:-1] + bytes([ct[-1] ^ 0x01])
    bad_token = base64.b64encode(iv + ct_bad_padding).decode()

    print("1. 정상 토큰:")
    result1 = decrypt_vulnerable(normal_token)
    print(f"   결과: {result1[1]}\n")

    print("2. 패딩 오류 토큰:")
    result2 = decrypt_vulnerable(bad_token)
    print(f"   결과: {result2[1]}\n")

    print("[!] 서버가 다른 오류 메시지를 반환합니다!")
    print("    공격자는 이 차이를 이용하여 바이트를 하나씩 복구할 수 있습니다.")

if __name__ == "__main__":
    print("=" * 60)
    print("Padding Oracle 공격 Exploit")
    print("=" * 60 + "\n")

    # 1. 취약점 설명
    demonstrate_vulnerability()

    # 2. 실제 공격 데모
    padding_oracle_attack_demo()

    print("\n" + "=" * 60)
    print("해결 방법:")
    print("1. 모든 오류에 대해 동일한 메시지 반환")
    print("2. 인증된 암호화 사용 (GCM, EAX 등)")
    print("3. 타이밍 공격 방지")
    print("=" * 60)
